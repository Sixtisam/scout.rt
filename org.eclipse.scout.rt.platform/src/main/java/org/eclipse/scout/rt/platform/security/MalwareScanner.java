/*
 * Copyright (c) 2010-2021 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 */
package org.eclipse.scout.rt.platform.security;

import java.io.File;
import java.io.FileInputStream;
import java.util.Arrays;

import org.eclipse.scout.rt.platform.ApplicationScoped;
import org.eclipse.scout.rt.platform.Bean;
import org.eclipse.scout.rt.platform.config.CONFIG;
import org.eclipse.scout.rt.platform.config.PlatformConfigProperties.MalwareScannerPathProperty;
import org.eclipse.scout.rt.platform.exception.PlatformException;
import org.eclipse.scout.rt.platform.resource.BinaryResource;
import org.eclipse.scout.rt.platform.util.IOUtility;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Facility used to scan files and resources for malware.
 * <p>
 * This default scanner assumes that an appropriate malware scanner is in place and scans a special folder using a
 * realtime filesystem scan strategy. Malware should therefore immediately be removed or blocked by the malware
 * implementation.
 * <p>
 * Override this {@link Bean} in order to implement another scanning strategy.
 *
 * @since 5.2
 */
@ApplicationScoped
public class MalwareScanner {
  private static final Logger LOG = LoggerFactory.getLogger(MalwareScanner.class);

  /**
   * This {@link MalwareScanner} copies the resource to be scanned into a special folder (specified by
   * {@link MalwareScannerPathProperty}), reads it back in and verifies the equality of the two streams.
   * <p>
   * Override this {@link Bean} in order to implement another scanning strategy.
   *
   * @throws PlatformException
   *           if the resource is valid and the scanner did not find any issues
   * @since 10.x
   */
  public void scan(BinaryResource res) {
    if (res == null) {
      return;
    }
    File directory = IOUtility.toFile(CONFIG.getPropertyValue(MalwareScannerPathProperty.class));
    if (directory != null && (!directory.exists() || !directory.isDirectory())) {
      LOG.error("Unable to check for malware because configured target path '{}' is invalid.", directory);
      throw new UnsafeResourceException("Resource '{}' may be unsafe (unable to check)", res.getFilename());
    }
    File f = null;
    try {
      byte[] expected = res.getContent();
      if (expected != null && expected.length > 0) {
        f = IOUtility.createTempFile("malware-scan", ".tmp", directory, expected);
        byte[] actual;
        try (FileInputStream in = new FileInputStream(f)) {
          actual = IOUtility.readBytes(in, expected.length);
        }
        if (!Arrays.equals(expected, actual)) {
          throwUnsafeResource(res);
        }
      }
    }
    catch (UnsafeResourceException e) {
      LOG.info(e.getMessage());
      throw e;
    }
    catch (Exception e) {//NOSONAR each on-site malware scanner may behave differently, e.g. StreamCorruptedException, FileNotFoundException, ...
      if (LOG.isDebugEnabled()) {
        LOG.debug("Exception while checking for malware", e);
      }
      throwUnsafeResource(res);
    }
    finally {
      IOUtility.deleteFile(f);
    }
  }

  protected void throwUnsafeResource(BinaryResource res) {
    LOG.info("detected unsafe resource '{}'", res.getFilename());
    throw new UnsafeResourceException("Resource '{}' is not safe", res.getFilename());
  }
}
